/*
 * Copyright (c) 2016, Fredrick Meunier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package xyz.meunier.wav2pzx.blockfinder;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Range;

import java.util.*;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Range.closed;
import static com.google.common.collect.Range.singleton;
import static java.lang.Math.round;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.averagingLong;
import static java.util.stream.Collectors.toList;

/**
 * RangeFinder has utility methods to analyse a list of pulses and classify them into different classes corresponding
 * to the theoretical idealised underlying pulse generated by the saving computer.
 */
final class RangeFinder {

    // If the gap between the last pair sum and the next one is > 500 then it is likely a different symbol
    private static final int MIN_INTER_SYMBOL_GAP = 500;
    private static final int PULSE_TOLERANCE = 50;

    private RangeFinder() {
    }

    /**
     * Analyse a provided collection of summed pairs of pulses assuming that they consist of a typical ZX Spectrum data
     * block with zero and one bits represented by pairs of equal sized pulses and return a list of Ranges that can be
     * used to classify the source pulses into their different underlying groups.
     * @param fullPulses the list of pulses to be analysed
     * @return the list of Ranges identified to correspond to the underlying pulse pairs
     * @throws NullPointerException if pulses was null
     */
    static List<Range<Long>> getRanges(Collection<Long> fullPulses) {
        checkNotNull(fullPulses, "fullPulses was null");

        List<Long> sortedPulses = fullPulses.stream().sorted().collect(toList());

        Optional<Long> first = sortedPulses.stream().findFirst();
        if(!first.isPresent()) {
            return emptyList();
        }

        Long bottomOfRange = first.get();
        if(sortedPulses.size() == 1) {
            return singletonList(singleton(bottomOfRange));
        }

        List<Range<Long>> foundRanges = new ArrayList<>();

        Long lastPulse = bottomOfRange;

        for(Long pulse : sortedPulses) {
            if(isaSignificantGapBetweenPulses(lastPulse, pulse)) {
                // We have a range
                foundRanges.add(getRange(bottomOfRange, lastPulse));

                bottomOfRange = pulse;
            }
            lastPulse = pulse;
        }

        if(bottomOfRange.equals(lastPulse)) {
            foundRanges.add(singleton(bottomOfRange));
        } else {
            foundRanges.add(getRange(bottomOfRange, lastPulse));
        }

        return ImmutableList.copyOf(foundRanges);
    }

    /**
     * Constructs a list of ranges, one singleton range for each provided pulse
     * @param pulses the collection of pulses
     * @return a list of singleton ranges, one for each non-null source pulse
     */
    static List<Range<Long>> getRangesForSinglePulses(Collection<Long> pulses) {
        checkNotNull(pulses, "pulses was null");
        return pulses.stream().filter(l -> l != null).sorted().map(Range::singleton).collect(toList());
    }

    /**
     * Get an average pulse for pulses in a supplied stream that fall into the supplied ranges.
     * @param ranges the classified ranges
     * @param fullBits the pulses to classify
     * @return a map of range to the average length of the matching pulses from the stream
     */
    static Map<Range<Long>, Long> getAveragePulseLengthsOfRanges(Iterable<Range<Long>> ranges, Collection<Long> fullBits) {
        Map<Range<Long>, Long> averages = new LinkedHashMap<>();

        for(Range<Long> range : ranges) {
            Long average = round(fullBits.stream().filter(range::contains).collect(averagingLong(l -> l)));
            averages.put(range, average);
        }
        return averages;
    }

    private static boolean isaSignificantGapBetweenPulses(Long lastPulse, Long pulse) {
        return (pulse - lastPulse) > MIN_INTER_SYMBOL_GAP;
    }

    private static Range<Long> getRange(Long bottomOfRange, Long lastPulse) {
        return closed(bottomOfRange - PULSE_TOLERANCE, lastPulse + PULSE_TOLERANCE);
    }

}
